import com.github.jengelman.gradle.plugins.shadow.tasks.ConfigureShadowRelocation
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

import java.util.concurrent.TimeUnit

buildscript {
    repositories {
        maven {
            name = "forge"
            url = "https://maven.minecraftforge.net"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
        maven {
            name = "jitpack"
            url = "https://jitpack.io"
        }
    }
    dependencies {
        classpath 'com.github.GTNewHorizons:ForgeGradle:1.2.11'
    }
}

plugins {
    id 'idea'
    id("org.ajoberstar.grgit") version("3.1.1")
    id("com.github.johnrengelman.shadow") version("4.0.4")
    id("com.palantir.git-version") version("0.12.3")
    id("maven-publish")
}

apply plugin: 'forge'

def projectJavaVersion = JavaLanguageVersion.of(8)

java {
    toolchain {
        languageVersion.set(projectJavaVersion)
    }
}

idea {
    module {
        inheritOutputDirs = true
        downloadJavadoc = true
        downloadSources = true
    }
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
    throw new GradleException("This project requires Java 8, but it's running on " + JavaVersion.current())
}

configurations.all {
    resolutionStrategy.cacheChangingModulesFor(0, TimeUnit.SECONDS)
    System.setProperty("org.gradle.internal.http.connectionTimeout", 120000 as String)
    System.setProperty("org.gradle.internal.http.socketTimeout", 120000 as String)
}

// Fix Jenkins' Git: chmod a file should not be detected as a change and append a '.dirty' to the version
'git config core.fileMode false'.execute()
// Pulls version from git tag
version = minecraftVersion + "-" + gitVersion()

group = modGroup
archivesBaseName = modId

minecraft {
    version = minecraftVersion + "-" + forgeVersion + "-" + minecraftVersion
    runDir = "run"

    if (replaceGradleTokenInFile) {
        replaceIn replaceGradleTokenInFile
        if (gradleTokenModId) {
            replace gradleTokenModId, modId
        }
        if (gradleTokenModName) {
            replace gradleTokenModName, modName
        }
        if (gradleTokenVersion) {
            replace gradleTokenVersion, versionDetails().lastTag
        }
        if (gradleTokenGroupName) {
            replace gradleTokenGroupName, modGroup
        }
    }
}

if (file("addon.gradle").exists()) {
    apply from: "addon.gradle"
}

configurations {
    implementation.extendsFrom(shadowCompile)
    implementation.extendsFrom(shadeCompile)
}

repositories {
    maven {
        name = "Overmind forge repo mirror"
        url = "https://gregtech.overminddl1.com/"
    }
}

task relocateShadowJar(type: ConfigureShadowRelocation) {
    target = tasks.shadowJar
    prefix = modGroup + ".shadow"
}

shadowJar {
    project.configurations.shadeCompile.each { dep ->
        from(project.zipTree(dep)) {
            exclude 'META-INF', 'META-INF/**'
        }
    }

    minimize()
    configurations = [project.configurations.shadowCompile]
    dependsOn(relocateShadowJar)
}

jar {
    project.configurations.shadeCompile.each { dep ->
        from(project.zipTree(dep)) {
            exclude 'META-INF', 'META-INF/**'
        }
    }
}

tasks.withType(JavaExec).configureEach {
    javaLauncher.set(
            javaToolchains.launcherFor {
                languageVersion = projectJavaVersion
            }
    )
}

processResources {
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'

        expand "minecraftVersion": project.minecraft.version,
                "modVersion": versionDetails().lastTag,
                "modId": modId,
                "modName": modName
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

task sourcesJar(type: Jar) {
    from(sourceSets.main.allJava)
    from(file("$projectDir/LICENSE"))
    getArchiveClassifier().set('sources')
}

task shadowDevJar(type: ShadowJar) {
    project.configurations.shadeCompile.each { dep ->
        from(project.zipTree(dep)) {
            exclude 'META-INF', 'META-INF/**'
        }
    }

    from sourceSets.main.output
    getArchiveClassifier().set("dev")

    minimize()
    configurations = [project.configurations.shadowCompile]
}

task relocateShadowDevJar(type: ConfigureShadowRelocation) {
    target = tasks.shadowDevJar
    prefix = modGroup + ".shadow"
}

task circularResolverJar(type: Jar) {
    dependsOn(relocateShadowDevJar)
    dependsOn(shadowDevJar)
    enabled = false
}

task devJar(type: Jar) {
    project.configurations.shadeCompile.each { dep ->
        from(project.zipTree(dep)) {
            exclude 'META-INF', 'META-INF/**'
        }
    }

    from sourceSets.main.output
    getArchiveClassifier().set("dev")
}

artifacts {
    archives sourcesJar
    archives devJar
}
